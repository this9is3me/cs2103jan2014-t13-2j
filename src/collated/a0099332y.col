//@author: a0099332y



	/**
	 * origin: C:\Users\Daryl Ho\Desktop\CS2103 Project\cs2103jan2014-t13-2j\src\todomato\DataSyncer.java
	 */

/**
 * This class is the process for the Google Sync of the application.
 * To sync with google calendar service. A remote API service is built by A009933Y 
 * to handle the main logic in sync process. DataSyncer hence only need to send 
 * HTTP Post Request and receive the response from the API server. No sync process 
 * is done locally. 
 * 
 * The API service is deployed in Heroku, written in Python, using Flask microframework.
 * 
 * 
 * Sample HTTP Post Request JSON:
 * 
 * {
 * 	"auth": {
 *   	"username": "todomatotest@gmail.com",
 *   	"password": "cs2103todomato",
 *   	"last_sync": "2014-04-14T15:55:55.000+08:00",
 *   	"current_time": "2014-04-14T15:56:25.000+08:00"
 * 	},
 * 	"data": {
 *   	"tasklist": [tasks]
 * 	}
 * }
 * 
 * tasks:
 *     {
 *     "created": "2014-04-14T15:56:22.000+08:00",
 *     "description": "0101",
 *     "edit": "2014-04-15T15:55:39.000+08:00",
 *     "eid": "http://www.google.com/calendar/feeds/qaefsdqnfhv66or3dp2psjko40%40group.
 *     			calendar.google.com/events/i57utfat7p3olsknjl139225o4",
 *     "enddate": "2014-04-14",
 *     "endtime": "20:00:00.000+08:00",
 *     "location": "utown",
 *     "meta": {
 *       "completed": "true",
 *       "id": "-2064010008",
 *       "priority": "LOW",
 *       "timecode": "0101"
 *     },
 *     "startdate": "2014-04-14",
 *    "starttime": "19:00:00.000+08:00"
 *   }
 * 
 * Once receive the response JSON, DataSyncer will reproduce Task Object based on each 
 * task in JSON.
 * 
 * 
 */

public class DataSyncer extends Processor {
	
	private static final String SYNC_ERROR = "Sync Error";
	private static final String SYNC_ERROR_MSG = "Sync Error: please check your data file";
	private static final String AUTHORIZATION_ERROR = "Authorization Error";
	private static final String AUTHORIZATION_ERROR_MSG = "Authorization Error: please check your password and username. Reset with \"setsync <username> <password>\"";
	private static final String ERROR_KEY_IN_JSON = "error";
	private static final int INDEX_OF_END_TIME = 3;
	private static final int INDEX_OF_END_DATE = 2;
	private static final int INDEX_OF_START_TIME = 1;
	private static final int INDEX_OF_START_DATE = 0;
	private static final String DEFAULT_KEY_IN_JSON = "1111";
	private static final String CURRENT_TIME_KEY_IN_JSON = "current_time";
	private static final String LAST_SYNC_TIME_KEY_IN_JSON = "last_sync";
	private static final String PASSWORD_KEY_IN_JSON = "password";
	private static final String USERNAME_KEY_IN_JSON = "username";
	private static final String EMPTY_STRING = "";
	private static final String TIMEZONE_INFO_AND_SECOND = ":00.000+08:00";
	private static final String TIME_FORMAT = "hh:mm";
	private static final String TIMEZONE_INFO = ".000+08:00";
	private static final String TIME_FORMAT_PRECISE = "hh:mm:ss";
	private static final String DATE_TIME_DIVIDER = "T";
	private static final String DATE_FORMAT = "YYYY-MM-DD";
	private static final String NULL_STRING = "null";
	private static final char TIME_CODE_NOT_VALID = '0';
	private static final String TIME_CREATED_KEY_IN_JSON = "created";
	private static final String UPDATE_TIME_KEY_IN_JSON = "edit";
	private static final String END_DATE_KEY_IN_JSON = "enddate";
	private static final String START_DATE_KEY_IN_JSON = "startdate";
	private static final String END_TIME_KEY_IN_JSON = "endtime";
	private static final String START_TIME_KEY_IN_JSON = "starttime";
	private static final String LOCATION_KEY_IN_JSON = "location";
	private static final String DESCRIPTION_KEY_IN_JSON = "description";
	private static final String EVENT_ID_KEY_IN_JSON = "eid";
	private static final String ID_KEY_IN_JSON = "id";
	private static final String PRIORITY_KEY_IN_JSON = "priority";
	private static final String IS_COMPLETED_KEY_IN_JSON = "completed";
	private static final String CONTENT_TYPE = "Content-type";
	private static final String APPLICATION_JSON = "application/json";
	private static final String TASKLIST_KEY_IN_JSON = "tasklist";
	private static final String META_KEY_IN_JSON = "meta";
	private static final String DATA_KEY_IN_JSON = "data";
	private static final String AUTHORIZATION_KEY_IN_JSON = "auth";
	private static final String TIMECODE_KEY_IN_JSON = "timecode";
	private static final String SERVER_URL = "http://todomato-sync.herokuapp.com/todomato/api/v1.0/update";
//	for local test:
//	private static final String SERVER_URL = "http://127.0.0.1:5000/todomato/api/v1.0/update";
	
	TaskList localList;


	public DataSyncer (TaskList localList) {
		this.localList = localList;
	}
	
	/**
	 * method for sync data with google calendar using a cloud server
	 * @param username (google account)
	 * @param password (google account)
	 * @param lastSyncTime
	 * @return TaskList
	 * @throws SyncErrorException 
	 * @throws IOException 
	 * @throws ParseException 
	 */
	public TaskList sync(String username, String password, DateTime lastSyncTime) throws SyncErrorException, ParseException, IOException {

		JsonObject localJson = prepareData(this.localList, username, password, lastSyncTime);
		JsonObject responseJson = sendRequest(localJson);
		localList = processResponse(responseJson);
		localList.setLastSyncTime(DateTime.now(TimeZone.getDefault()));
		localList.setUserName(username);
		localList.setPassword(password);
		
		return localList;
	}
	
	/**
	 * main function for creating JSON object from local data information. The object will be sent to cloud server.
	 * @param localList
	 * @param username
	 * @param password
	 * @param lastSyncTime
	 * @return
	 */
	private JsonObject prepareData(TaskList localList, String username, String password, DateTime lastSyncTime) {
		
		// create JSON objects for response
		JsonObject localJson = new JsonObject();
		JsonObject auth = new JsonObject();
		JsonObject data = new JsonObject();
		
		// add in header data for the response JSON
		initResponseJson(username, password, lastSyncTime, localJson, auth);
		JsonArray tasklist = createTaskJsonArray(localList);
		
		// add tasklist in response JSON
		data.add(TASKLIST_KEY_IN_JSON, tasklist);
		localJson.add(DATA_KEY_IN_JSON, data);
		return localJson;
	}
	
	/**
	 * main function for sending HTTP request with JSON object that contains Task info
	 * @param localJson
	 * @return
	 * @throws IOException 
	 * @throws ParseException 
	 */
	private JsonObject sendRequest(JsonObject localJson) throws ParseException, IOException {
		
		HttpClient client = HttpClientBuilder.create().build();
		String postUrl = SERVER_URL;
		HttpPost post = new HttpPost(postUrl);
		StringEntity postingString;
		
		postingString = new StringEntity(localJson.toString());
		post.setEntity(postingString);
		post.setHeader(CONTENT_TYPE, APPLICATION_JSON );
		
		HttpResponse response = client.execute(post);
		String json = EntityUtils.toString(response.getEntity());
		JsonParser jsonParser = new JsonParser();
		JsonObject tJson = (JsonObject)jsonParser.parse(json);
		
		return tJson;
		
	}

	/**
	 * main function for turning response (in JSON format) into Tasks and add all tasks into a TaskList
	 * @param responseJson
	 * @return
	 */
	private TaskList processResponse(JsonObject responseJson) throws SyncErrorException {
		
		if (responseJson.has(TASKLIST_KEY_IN_JSON)) {
			// Initialization
			TaskList output = new TaskList();
			JsonArray tasklist = responseJson.getAsJsonArray(TASKLIST_KEY_IN_JSON);
			
			// convert task Json to Task for all jsons in the tasklist
			for(JsonElement t: tasklist) {
				Task task = convertJsonToTask(t);
				output.addToList(task);
			}
			
			return output;
		
		} else if (responseJson.has(ERROR_KEY_IN_JSON)) {
			String errorMessage = responseJson.get(ERROR_KEY_IN_JSON).getAsString();
			if( errorMessage.equals(AUTHORIZATION_ERROR)){
				throw new SyncErrorException(AUTHORIZATION_ERROR_MSG);
			}
			
			if ( errorMessage.equals(SYNC_ERROR)){
				throw new SyncErrorException(SYNC_ERROR_MSG);
			}
			
		}
		return localList;
		
	}
	

	/**
	 * helper function for converting JSON into Task Object
	 * @param json
	 * @return a Task generate from task Json
	 * @throws NumberFormatException
	 */
	private Task convertJsonToTask(JsonElement json) throws NumberFormatException {
		
		JsonObject tJson = json.getAsJsonObject();
		
		JsonObject meta = tJson.get(META_KEY_IN_JSON).getAsJsonObject();
		
		
		// get meta data
		String timeCode = meta.get(TIMECODE_KEY_IN_JSON).getAsString();
		boolean isCompleted = meta.get(IS_COMPLETED_KEY_IN_JSON).getAsBoolean();
		String priorityLevel = meta.get(PRIORITY_KEY_IN_JSON).getAsString();
		JsonElement idJson = meta.get(ID_KEY_IN_JSON);
		
		// get normal data
		String eventId = tJson.get(EVENT_ID_KEY_IN_JSON).getAsString();
		String description = tJson.get(DESCRIPTION_KEY_IN_JSON).getAsString();
		String location = tJson.get(LOCATION_KEY_IN_JSON).getAsString();
		DateTime startTime = stringToTime(tJson.get(START_TIME_KEY_IN_JSON).getAsString());
		DateTime endTime = stringToTime(tJson.get(END_TIME_KEY_IN_JSON).getAsString());
		DateTime startDate = stringToDate(tJson.get(START_DATE_KEY_IN_JSON).getAsString());
		DateTime endDate = stringToDate(tJson.get(END_DATE_KEY_IN_JSON).getAsString());
		DateTime updateTime = stringToDateTime(tJson.get(UPDATE_TIME_KEY_IN_JSON).getAsString());
		DateTime timeCreated = stringToDateTime(tJson.get(TIME_CREATED_KEY_IN_JSON).getAsString());
		
		ArrayList<DateTime> taskTime = createDateTimeForATask(timeCode, startDate, startTime, endDate, endTime);
		Integer id = null;
		
		if (!idJson.isJsonNull()){
			id = Integer.parseInt(idJson.getAsString());
		}
		
		Task task = createATask(isCompleted, priorityLevel, eventId, description,
				location, updateTime, timeCreated, taskTime, id);
		
		return task;
	}

	/**
	 * helper function to create a Task object based on values in JSON
	 * @param isCompleted
	 * @param priorityLevel
	 * @param eventId
	 * @param description
	 * @param location
	 * @param updateTime
	 * @param timeCreated
	 * @param taskTime
	 * @param id
	 * @return
	 */
	private Task createATask(boolean isCompleted, String priorityLevel,
			String eventId, String description, String location,
			DateTime updateTime, DateTime timeCreated,
			ArrayList<DateTime> taskTime, Integer id) {
		DateTime startDate = taskTime.get(INDEX_OF_START_DATE);
		DateTime startTime = taskTime.get(INDEX_OF_START_TIME);
		DateTime endDate = taskTime.get(INDEX_OF_END_DATE);
		DateTime endTime = taskTime.get(INDEX_OF_END_TIME);
	
		Task task = new Task(description);
		
		if(id != null){
			task.setId(id);
		}
		
		task.setStartTime(startTime);
		task.setEndTime(endTime);
		task.setStartDate(startDate);
		task.setEndDate(endDate);		
		task.setLocation(location);
		
		task.setTimeCreated(timeCreated);
		task.setEventId(eventId);
		task.setUpdateTime(updateTime);
		task.setPriorityLevel(priorityLevel);
		task.setCompleted(isCompleted);
		
		return task;
	}

	
	/**
	 * helper function to validate time attributes from JSON. Sync process from Google Calendar 
	 * may include additional invalid time attributes in JSON. 
	 * @param timeCode
	 * @param startDate
	 * @param startTime
	 * @param endDate
	 * @param endTime
	 * @return a timeArray which set the invalid time attribute to null
	 */
	private ArrayList<DateTime> createDateTimeForATask(String timeCode,
			DateTime startDate, DateTime startTime, DateTime endDate, DateTime endTime) {
		
		ArrayList<DateTime> timeArray = new ArrayList<DateTime>();
		timeArray.add(startDate);
		timeArray.add(startTime);
		timeArray.add(endDate);
		timeArray.add(endTime);

		for(int i = 0; i < timeCode.length(); i++){
			boolean isValidData = timeCode.charAt(i) != TIME_CODE_NOT_VALID;
			if(!isValidData){
				timeArray.set(i, null);
			}
		}
		
		return timeArray;
	}


	/** 
	 * helper function to format DateTime Object based on the data it contains
	 * @param dt
	 * @return YYYY-MM-DDThh:mm:ss.000+08:00 for DateTime Object with all data; 
	 * YYYY-MM-DD with date data only;
	 * hh:mm:00.000+08:00 for DateTime Object with time data only;
	 * Empty String if the Object is null
	 */
	private String formatTime(DateTime dt) {
		boolean datetimeIsNull = dt == null || dt.toString().equals(NULL_STRING);
		if (datetimeIsNull) {
			return EMPTY_STRING;
		} else if (dt.hasYearMonthDay() && isTime(dt)){
			return dt.format(DATE_FORMAT) + DATE_TIME_DIVIDER + dt.format(TIME_FORMAT_PRECISE) + TIMEZONE_INFO;
		} else if (!dt.hasYearMonthDay() && isTime(dt)){
			return dt.format(TIME_FORMAT) + TIMEZONE_INFO_AND_SECOND;
		} else if (!isTime(dt) && dt.hasYearMonthDay()){
			return dt.format(DATE_FORMAT);
		} else {
			return EMPTY_STRING;
		}
	}
	
	
	/** 
	 * helper function to check if a DateTime Object has Hour and Minute ONLY
	 * @param dt
	 * @return true if the object has Hour and Minute ONLY
	 */
	private boolean isTime(DateTime dt) {
		// check if dt is time hh:mm
		if (dt.getHour() != null && dt.getMinute()!= null){
			return true;
		} else {
			return false;
		}
	}

	/**
	 * helper function to convert a string to DateTime Object
	 * @param s
	 * @return a DateTime Object with Year, Month, Day, Hour, Minute, Second
	 */
	private DateTime stringToDateTime(String s) {
		DateTime dt = new DateTime(s.substring(0,19));
		return dt;
	}
	
	/**
	 * helper function to convert a string to DateTime Object
	 * @param s
	 * @return a DateTime Object with Year, Month, Day ONLY
	 */
	private DateTime stringToDate(String s) {
		DateTime d = null;
		if (!s.isEmpty()){
			d = new DateTime(s);
		}
		
		return d;
	}
	
	/**
	 * helper function to convert a string to DateTime Object
	 * @param s
	 * @return a DateTime Object with Hour, Minute, Second ONLY
	 */
	private DateTime stringToTime(String s) {
		DateTime t = null;
		if (!s.isEmpty()){
			t = new DateTime(s.substring(0, 5));
		}
		
		return t;
	}
	
	/**
	 * helper function to check if a string is null string or is null
	 * @param s
	 * @return true if the string is not a null string or is not a null object
	 */
	private boolean notNullString(String s) {
		boolean isNullString = (s == null || s.equals(NULL_STRING));
		return !isNullString;
	}

	

	/**
	 * helper function to convert the local TaskList into JSON format
	 * @param localList
	 * @return JsonArray that contains tasks in Json
	 */
	private JsonArray createTaskJsonArray(TaskList localList) {
		ArrayList<Task> list = localList.getList();
		JsonArray tasklist = new JsonArray();
		for (Task t: list) {
			JsonObject tJson = convertTaskToJson(t);
			tasklist.add(tJson);
		}

		return tasklist;
	}

	/**
	 * helper function to initialize the JSON that is going to be send to the server
	 * @param username
	 * @param password
	 * @param lastSyncTime
	 * @param localJson
	 * @param auth
	 */
	private void initResponseJson(String username, String password,
			DateTime lastSyncTime, JsonObject localJson, JsonObject auth) {
		auth.addProperty(USERNAME_KEY_IN_JSON, username);
		auth.addProperty(PASSWORD_KEY_IN_JSON, password);
		auth.addProperty(LAST_SYNC_TIME_KEY_IN_JSON, formatTime(lastSyncTime));
		auth.addProperty(CURRENT_TIME_KEY_IN_JSON, formatTime(DateTime.now(TimeZone.getDefault())));
		localJson.add(AUTHORIZATION_KEY_IN_JSON, auth);
	}

	/**
	 * helper function to create an JSON object from the local Task
	 * @param t
	 * @return JsonObject that made from the task
	 */
	private JsonObject convertTaskToJson(Task t) {
		
		JsonObject tJson = new JsonObject();
		
		// if the task has never been updated, set its updateTime to its createTime
		if(t.getUpdateTime() == null) {
			t.setUpdateTime(t.getTimeCreated());
		}
		
		// Get local Task data
		String id = Integer.toString(t.getId());
		String description = t.getDescription();
		String starttime = formatTime(t.getStartTime());
		String startdate = formatTime(t.getStartDate());
		String endtime = formatTime(t.getEndTime());
		String enddate = formatTime(t.getEndDate());
		String created = formatTime(t.getTimeCreated());
		String edit = formatTime(t.getUpdateTime());
		String location = t.getLocation();
		String eid = t.getEventId();
		String completed  = t.getCompleted().toString();
		String timecode = generateTimeCode(t);
		String priority = t.getPriorityLevel();
		
		// write meta data into JSON object
		JsonObject meta = new JsonObject();
		meta.addProperty(ID_KEY_IN_JSON, id);
		meta.addProperty(TIMECODE_KEY_IN_JSON, timecode);
		meta.addProperty(PRIORITY_KEY_IN_JSON, priority);
		meta.addProperty(IS_COMPLETED_KEY_IN_JSON, completed);
		tJson.add(META_KEY_IN_JSON, meta);
		
		// write basic data into JSON object
		if (notNullString(description)){
			tJson.addProperty(DESCRIPTION_KEY_IN_JSON, description);
		}
		
		if (notNullString(starttime)){
			tJson.addProperty(START_TIME_KEY_IN_JSON, starttime);
		}
		
		if (notNullString(startdate)){
			tJson.addProperty(START_DATE_KEY_IN_JSON, startdate);
		}
		
		if (notNullString(enddate)){
			tJson.addProperty(END_DATE_KEY_IN_JSON, enddate);
		}
		
		if (notNullString(endtime)){
			tJson.addProperty(END_TIME_KEY_IN_JSON, endtime);
		}
		
		if (notNullString(created)){
			tJson.addProperty(TIME_CREATED_KEY_IN_JSON, created);
		}
		
		if (notNullString(location)){
			tJson.addProperty(LOCATION_KEY_IN_JSON, location);
		}else{
			tJson.addProperty(LOCATION_KEY_IN_JSON, EMPTY_STRING);
		}
		
		if (notNullString(eid)){
			tJson.addProperty(EVENT_ID_KEY_IN_JSON, eid);
		}
		
		if (notNullString(edit)){
			tJson.addProperty(UPDATE_TIME_KEY_IN_JSON, edit);
		}

		return tJson;
	}
	
	
	/**
	 * helper function to generate the timeCode for each Task based on the existence of its time attribute
	 * timeCode records the existence of a Task's time attribute (startDate, startTime, endDate, endTime)
	 * It is a four digit number that corresponds to four time attribute in the order of 
	 * (startDate, startTime, endDate, endTime)
	 * @param t
	 * @return timeCode in following format:
	 * 		"dddd"
	 * 		
	 * 		d: a binary digit of 0 or 1
	 * 		0: time attribute does not exist
	 * 		1: time attribute exists
	 * 		
	 * 		eg.
	 * 		A Task object has a timeCode of "1011"
	 * 		The Task object has startDate, endDate, endTime but not startTime
	 */
	private String generateTimeCode(Task t) {
		String timeCode = DEFAULT_KEY_IN_JSON;
		char[] timeCodeChars = timeCode.toCharArray();
		
		if(t.getStartDate() == null){
			timeCodeChars[INDEX_OF_START_DATE] = TIME_CODE_NOT_VALID;
		}
		
		if(t.getStartTime() == null){
			timeCodeChars[INDEX_OF_START_TIME] = TIME_CODE_NOT_VALID;
		}
		
		if(t.getEndDate() == null){
			timeCodeChars[INDEX_OF_END_DATE] = TIME_CODE_NOT_VALID;
		}
		
		if(t.getEndTime() == null){
			timeCodeChars[INDEX_OF_END_TIME] = TIME_CODE_NOT_VALID;
		}
		
		timeCode = String.valueOf(timeCodeChars);
				
		return timeCode;
	}
}

	// End of segment: C:\Users\Daryl Ho\Desktop\CS2103 Project\cs2103jan2014-t13-2j\src\todomato\DataSyncer.java





	/**
	 * origin: C:\Users\Daryl Ho\Desktop\CS2103 Project\cs2103jan2014-t13-2j\src\todomato\FileHandler.java
	 */

/**
 * This class reads, writes, and updates a local data file stored
 * on the user's computer. It reads in tasks as Task objects.
 *
 */

public class FileHandler {
	
	private static final String LINE_BREAK = "\r\n";
	private String fileLocation;
	private File file;
	
	/**
	 * @param fileLoc
	 */
	public FileHandler (String fileLoc) {
		this.fileLocation = fileLoc;
		this.file = createNewFileWhenNotExist(new File (fileLocation));	
	}
	
	public File createNewFileWhenNotExist (File f) {
		File dataFile = f;
		if(!f.exists()) {
			try {
				FileWriter fw = new FileWriter(f.getAbsoluteFile());
			} catch (IOException e) {
				return null;
			}
		}
		return dataFile;
	}

	/**
	 * @return a task list generated by strings in the data file
	 */
	public TaskList readFile() {
		
		try {
			Boolean isSyncTimeRetrieved = false;
			Boolean isUserNameRetrieved = false;
			Boolean isPasswordRetrieved = false;
			String currentLine;
			Task currentTask;
			TaskList taskList = new TaskList();
			BufferedReader bufferedReader = new BufferedReader(new FileReader(file.getAbsoluteFile()));
		
			while ((currentLine = bufferedReader.readLine()) != null) {
				if (!isSyncTimeRetrieved) {
					taskList.setLastSyncTime (new DateTime(currentLine));
					isSyncTimeRetrieved = true;
				} else if (!isUserNameRetrieved) {
					taskList.setUserName(currentLine);
					isUserNameRetrieved = true;
				} else if (!isPasswordRetrieved) {
					taskList.setPassword(currentLine);
					isPasswordRetrieved = true;
				} else {
					currentTask = readTask(currentLine);
					taskList.addToList(currentTask);
				}
			}
			
			bufferedReader.close();
			return taskList;
			
		} catch (IOException e) {
			return null;
			
		}
			
			
	}
	
	/**
	 * @param taskList the updated task list stored in runtime
	 * @return the updated task list generated by strings in the date file
	 * @throws IOException
	 */
	public TaskList updateFile(TaskList taskList) {
		
		try {
		
			String content;
			
			FileWriter fileWriter = new FileWriter(file.getAbsoluteFile());
			BufferedWriter bufferedWriter = new BufferedWriter(fileWriter);
			
	
			if (!file.exists()) {
				file.createNewFile();
			}
			
			content = taskList.getLastSyncTime() + LINE_BREAK + taskList.getUserName() 
					+ LINE_BREAK + taskList.getPassword() + LINE_BREAK;
			bufferedWriter.write(content);
			
			for (Task task : taskList.getList()) {
				content = task.toFileString() + LINE_BREAK;
				bufferedWriter.write(content);
			}
	
			bufferedWriter.close();
			
			TaskList updatedList = readFile();
			
			
			return updatedList;
		
		} catch (IOException e) {
			
			//TODO
			return null;
			
		}
	}
	
	/**
	 * @param line each line in data file that represents a task
	 * @return task generated by the input line
	 */
	
	private Task readTask(String line) {
		Task task = null;
		task = Task.createTaskFromFileString(line);
		return task;
	}
	
	
}

	// End of segment: C:\Users\Daryl Ho\Desktop\CS2103 Project\cs2103jan2014-t13-2j\src\todomato\FileHandler.java





	/**
	 * origin: C:\Users\Daryl Ho\Desktop\CS2103 Project\cs2103jan2014-t13-2j\src\todomato\SyncErrorException.java
	 */


/**
 * This class signals that there is an error occur in sync process.
 *
 */
@SuppressWarnings("serial")
public class SyncErrorException extends Exception {

	/**
	 * @param message
	 */
	public SyncErrorException(String message) {
		super(message);
	}
	
    /**
     * @param message
     * @param throwable
     */
    public SyncErrorException(String message, Throwable throwable) {
        super(message, throwable);
    }
    
    /* (non-Javadoc)
     * @see java.lang.Throwable#getMessage()
     */
    public String getMessage()
    {
        return super.getMessage();
    }
}

	// End of segment: C:\Users\Daryl Ho\Desktop\CS2103 Project\cs2103jan2014-t13-2j\src\todomato\SyncErrorException.java





	/**
	 * origin: C:\Users\Daryl Ho\Desktop\CS2103 Project\cs2103jan2014-t13-2j\src\todomato\SyncProcessor.java
	 */

/**
 * This is the class that handles google sync function
 *
 */
public class SyncProcessor extends Processor {

	private static final String NO_USERNAME_PW = "Set username and password with \"setsync <username> <password>\"";
	private static final String SYNC_COMPLETE = "Sync completed";
	private static final String CONNECTION_ERROR = "Connection Error: Please check your Internet Connection";
	private static final String SYNC_ERROR = "Sync Error: Oops, A Unknown Sync Error has occurred!";
	
	public static String processSync() {
		
		// Prepare google login credentials
		if ((list.getUserName() == null && list.getPassword() == null) ||
		(list.getUserName().equals("null") && list.getPassword().equals("null"))){
			return NO_USERNAME_PW;
		}
		String username = list.getUserName();
		String password = list.getPassword();
		
		// Sync and replace the local Tasklist
		DataSyncer Syncer = new DataSyncer(list);
		TaskList newList;
		try {
			newList = Syncer.sync(username, password, list.getLastSyncTime());
		} catch (ParseException e) {
			return SYNC_ERROR;
		} catch (SyncErrorException e) {
			return e.getMessage();
		} catch (IOException e) {
			return CONNECTION_ERROR;
		}
		list = newList;
		fileHandler.updateFile(list);
		displayList.deepCopy(list);
		
		return SYNC_COMPLETE;

	}
}
	// End of segment: C:\Users\Daryl Ho\Desktop\CS2103 Project\cs2103jan2014-t13-2j\src\todomato\SyncProcessor.java





	/**
	 * origin: C:\Users\Daryl Ho\Desktop\CS2103 Project\cs2103jan2014-t13-2j\src\todomato-sync-server\app.py
	 */


#!flask/bin/python
from flask import Flask, jsonify, request
import gdata.calendar.data
import gdata.calendar.client
import gdata.calendar.service
import gdata.acl.data
import string
import sys
import datetime
import time
import atom
import ast
import xmltodict
import json

app = Flask(__name__)


# helper functions
def run_async(func):
    """
        run_async(func)
            function decorator, intended to make "func" run in a separate
            thread (asynchronously).
            Returns the created Thread object

            E.g.:
            @run_async
            def task1():
                do_something

            @run_async
            def task2():
                do_something_too

            t1 = task1()
            t2 = task2()
            ...
            t1.join()
            t2.join()
    """
    from threading import Thread
    from functools import wraps

    @wraps(func)
    def async_func(*args, **kwargs):
        func_hl = Thread(target = func, args = args, kwargs = kwargs)
        func_hl.start()
        return func_hl

    return async_func


def normalize_time(datetime_string):
    datetime_string = (datetime.datetime.strptime(datetime_string, "%Y-%m-%dT%H:%M:%S.000Z") + datetime.timedelta(hours=8)).strftime("%Y-%m-%dT%H:%M:%S.000+08:00")
    return datetime_string

def string_to_time(datetime_string):
    if datetime_string is '':
        return None
    return datetime.datetime.strptime(datetime_string, "%Y-%m-%dT%H:%M:%S.000+08:00")

def date_only(datetime_string):
    return '-' in datetime_string and ':' not in datetime_string

def time_only(datetime_string):
    return ':' in datetime_string and '-' not in datetime_string

def date_and_time(datetime_string):
    return 'T' in datetime_string

def init(local_auth):
    username = local_auth['username']
    password = local_auth['password']

    client = gdata.calendar.client.CalendarClient(source='Todomato')
    client.ClientLogin(username, password, client.source)

    feed = client.GetAllCalendarsFeed()
   
    cid = None
    cal_url = None

    # create or get todomato calendar list
    for i, cal in zip(xrange(len(feed.entry)), feed.entry):
        if cal.title.text == "Todomato":
            cal_url = cal.id.text
            print 'new calendar created: No'
    if cal_url is None:
        print 'new calendar created: Yes'
        calendar = gdata.calendar.data.CalendarEntry()
        calendar.title = atom.data.Title(text="Todomato")
        calendar.timezone = gdata.calendar.data.TimeZoneProperty(value="Asia/Singapore")
        cal_url = client.InsertCalendar(new_calendar=calendar).id.text

    cid = cal_url.split("http://www.google.com/calendar/feeds/default/calendars/")[1]
    feed_uri = "http://www.google.com/calendar/feeds/%s/private/full" %(cid,)
    
    # get calendar events
    remote_tasklist = get_remote_tasks(client, feed_uri)

    return remote_tasklist, client, feed_uri

def update(client, feed_uri, local_tasklist, remote_tasklist, last_sync, time_offset):

    if len(local_tasklist) == 0 and last_sync is '':
        local_tasklist = remote_tasklist
        return local_tasklist
    elif len(remote_tasklist) == 0 and last_sync is '':
        remote_tasklist = create_remote_tasks(client, feed_uri, local_tasklist)
        local_tasklist = remote_tasklist
        return local_tasklist
    else:
        for i in range(0, len(local_tasklist)):
            task = local_tasklist[i]
            last_sync_time = string_to_time(last_sync)

        # local create
            if 'eid' not in task or last_sync_time is None:
                updated_task = create_remote_task(client, feed_uri, task)
                local_tasklist[i] = updated_task
                print "local create, sync at remote: ", task['description'] , ' created'
            else:
                last_sync_time = last_sync_time - time_offset
                eid = task['eid']
                event = get_event_by_eid(remote_tasklist, eid)
                local_updated_time = string_to_time(task['edit']) - time_offset
        # remote delete
                if event is None and local_updated_time < last_sync_time:
                    local_tasklist[i] = None
                    print "remote delete, sync at local: ", task['description'], ' deleted'
                elif event is not None:
                    remote_updated_time = string_to_time(event['edit'])
        # local or remote update

                    if local_updated_time > last_sync_time or remote_updated_time > last_sync_time:
                        if local_updated_time > remote_updated_time:
                            print local_updated_time, remote_updated_time
                            local_tasklist[i] = update_remote_task(client, feed_uri, eid, task)
                            print "local update, sync at remote: ", task['description'], ' updated'
                        elif local_updated_time < remote_updated_time:
                            print local_updated_time, remote_updated_time
                            local_tasklist[i] = event
                            print "remote update, sync at local: ", task['description'], ' updated'

        
        for event in remote_tasklist:
            eid = event['eid']
            id = event['meta']['id']
            remote_updated_time = string_to_time(event['edit'])
            local_task = get_event_by_eid(local_tasklist, eid)
            if local_task is None:
                last_sync_time = string_to_time(last_sync)
        # remote create
                if last_sync_time is None or (id is None and remote_updated_time + time_offset > last_sync_time):
                    local_tasklist.append(event)
                    print "remote create, sync at local: ", event['description'], ' created'
        # local detele      
                else:
                    delete_event(client, eid, feed_uri)

        local_tasklist = [t for t in local_tasklist if t is not None]

        return local_tasklist

@run_async
def delete_event(client, eid, feed_uri):
    event_uri = feed_uri + '/' + eid[-26:]
    e = client.get_calendar_entry(event_uri, desired_class=gdata.calendar.data.CalendarEventEntry)
    print "local delete, sync at remote: ", e.title.text, ' deleted'
    client.Delete(e)

def get_event_by_eid(tasklist, eid):
    for event in tasklist:
        if event is not None and event['eid'] == eid:
            return event
    return None

def event_to_json(event):
    xmlstring = event.ToString()
    xml_dict = xmltodict.parse(xmlstring, process_namespaces=True)
    edit_time = normalize_time(xml_dict['http://www.w3.org/2005/Atom:entry']['http://www.w3.org/2005/Atom:updated'])
    created_time = normalize_time(xml_dict['http://www.w3.org/2005/Atom:entry']['http://www.w3.org/2005/Atom:published'])

    if (event.content.text is None):
        timecode = '1111'
        id = None
        priority = "LOW"
        completed = "false"
    else:
        meta = eval(event.content.text)
        timecode = meta['timecode']
        id = meta['id']
        priority = meta['priority']
        completed = meta['completed']

    start = event.when[0].start
    end = event.when[0].end
    startdate = start.split('T')[0]
    enddate = end.split('T')[0]
    starttime = ""
    endtime = ""

    if date_and_time(start) and date_and_time(end):
        starttime = start.split('T')[1]
        endtime = end.split('T')[1]

    time = [startdate, starttime, enddate, endtime]
    has_start_date = (timecode[0] == '1')
    has_start_time = (timecode[1] == '1')
    has_end_date = (timecode[2] == '1')
    has_end_time = (timecode[3] == '1')

    if not has_start_date:
        startdate = ""
    if not has_start_time:
        starttime = ""
    if not has_end_date:
        enddate = ""
    if not has_end_time:
        endtime = ""

    event_dict = {
            'meta':{
                'id':id,
                'priority':priority,
                'completed':completed,
                'timecode':timecode,
            },
            'eid': event.id.text,
            'description':event.title.text,
            'startdate':startdate,
            'starttime':starttime,
            'enddate':enddate,
            'endtime':endtime,
            'location':event.where[0].value,
            'edit': edit_time,
            'created': created_time,
        }

    # print json.dumps(event_dict, sort_keys=True, indent=4)

    return event_dict

def get_remote_tasks(client, feed_uri):
    feed = client.GetCalendarEventFeed(uri=feed_uri)
    remote_tasklist = []
    for i, event in zip(xrange(len(feed.entry)), feed.entry):
        event_dict = event_to_json(event)
        remote_tasklist.append(event_dict)
    return remote_tasklist

def create_remote_tasks(client, feed_uri, local_tasklist):
    for task in local_tasklist:
        create_remote_task(client, feed_uri, task)
    remote_tasklist = get_remote_tasks(client, feed_uri)
    return remote_tasklist

def process_datetime_from_timecode(task):\

    timecode = task['meta']['timecode']

    has_start_date = (timecode[0] == '1')
    has_start_time = (timecode[1] == '1')
    has_end_date = (timecode[2] == '1')
    has_end_time = (timecode[3] == '1')

    starttime = task['starttime']
    endtime = task['endtime']
    startdate = task['startdate']
    enddate = task['enddate']

    if starttime is not "":
        starttime_dt = datetime.datetime.strptime(starttime[:5], "%H:%M")
    else:
        starttime_dt = None

    if startdate is not "":
        startdate_dt = datetime.datetime.strptime(startdate[:10], "%Y-%m-%d")
    else:
        startdate_dt = None

    if endtime is not "":
        endtime_dt = datetime.datetime.strptime(endtime[:5], "%H:%M")
    else:
        endtime_dt = None

    if enddate is not "":
        enddate_dt = datetime.datetime.strptime(enddate[:10], "%Y-%m-%d")
    else:
        enddate_dt = None

    print starttime_dt, endtime_dt

    # process data

    # 1111
    if has_start_date and has_start_time and has_end_date and has_end_time:
        pass
    # 1101
    elif has_start_date and has_start_time and has_end_time and not has_end_date:
        print starttime_dt > endtime_dt
        if starttime_dt > endtime_dt:
            enddate = (startdate_dt + datetime.timedelta(days=1)).strftime("%Y-%m-%d")
        else:
            enddate = startdate

    # 1110
    elif has_start_date and has_start_time and has_end_date and not has_end_time:
        endtime = starttime

    # 1011
    elif has_start_date and not has_start_time and has_end_date and has_end_time:
        starttime = endtime

    # 0111
    elif not has_start_date and has_start_time and has_end_date and has_end_time:
        if starttime_dt > endtime_dt:
            startdate = (enddate_dt - datetime.timedelta(days=1)).strftime("%Y-%m-%d")
        else:
            startdate = enddate

    # 1100
    elif has_start_date and has_start_time and not has_end_date and not has_end_time:
        enddate = startdate
        endtime = starttime

    # 0101
    elif not has_start_date and has_start_time and not has_end_date and has_end_time:
        startdate = (datetime.datetime.now() + datetime.timedelta(hours=8)).strftime("%Y-%m-%d")
        enddate = startdate

    # 0110
    elif not has_start_date and has_start_time and has_end_date and not has_end_time:
        startdate = enddate
        endtime = starttime

    # 1001
    elif has_start_date and not has_start_time and not has_end_date and has_end_time:
        enddate = startdate
        starttime = endtime

    # 1010
    elif has_start_date and not has_start_time and has_end_date and not has_end_time:
        pass

    # 0011
    elif not has_start_date and not has_start_time and has_end_date and has_end_time:
        starttime = endtime
        startdate = enddate

    # 0100
    elif not has_start_date and has_start_time and not has_end_date and not has_end_time:
        endtime = starttime
        startdate = (datetime.datetime.now() + datetime.timedelta(hours=8)).strftime("%Y-%m-%d")
        enddate = startdate

    # 1000
    elif has_start_date and not has_start_time and not has_end_date and not has_end_time:
        enddate = startdate

    # 0001
    elif not has_start_date and not has_start_time and not has_end_date and has_end_time:
        starttime = endtime
        enddate = startdate = (datetime.datetime.now() + datetime.timedelta(hours=8)).strftime("%Y-%m-%d")

    # 0010
    elif not has_start_date and not has_start_time and has_end_date and not has_end_time:
        startdate = enddate
    # 0000
    else:
        enddate = startdate = (datetime.datetime.now() + datetime.timedelta(hours=8)).strftime("%Y-%m-%d")

    if starttime == "" or endtime == "":
        start = startdate
        end = enddate
    else:
        start = startdate + 'T' + starttime
        end = enddate + 'T' + endtime

    return start, end


def create_remote_task(client, feed_uri, task):

    # process meta
    meta = task['meta']

    start, end = process_datetime_from_timecode(task)

    event = gdata.calendar.data.CalendarEventEntry()

    starttime = task['starttime']
    endtime = task['endtime']

    event.title = atom.data.Title(task['description'])
    event.content = atom.data.Content(str(task['meta']))
    event.where.append(gdata.data.Where(value=task['location']))
    event.when.append(gdata.data.When(start=start, end=end))
    event = client.InsertEvent(event, feed_uri)
    event_json = event_to_json(event)
    if event_json['edit'] == "1970-01-01T08:00:00.000+08:00":
        event_json['edit'] = task['edit']
    return event_json

def update_remote_task(client, feed_uri, eid, task):
    event_uri = feed_uri + '/' + eid[-26:]
    event = client.get_calendar_entry(event_uri, desired_class=gdata.calendar.data.CalendarEventEntry)

    meta = task['meta']

    start, end = process_datetime_from_timecode(task)
    
    event.title.text = task['description']
    event.content.text = str(task['meta'])
    event.where[0].value = task['location']

    event.when[0].start = start
    event.when[0].end = end
    event = client.Update(event)
    return event_to_json(event)

@app.route('/todomato/api/v1.0/update', methods = ['POST'])
def update_task():

    local_data = ast.literal_eval(request.get_data())

    current_time = string_to_time(local_data['auth']['current_time'])
    #server_time = (datetime.datetime.now() + datetime.timedelta(hours=8))
    server_time = current_time
    #server_time.replace(microsecond = 0)
    time_offset = current_time - server_time
    print "\nSTART SYNCING \n====================\ntime offset: ", time_offset
    # print "\nLOCAL DATA RECEIVED \n====================\nlocal data: \n", json.dumps(local_data, sort_keys=True, indent=4)
    
    local_tasklist = local_data['data']['tasklist']
    local_auth = local_data['auth']
    last_sync = local_data['auth']['last_sync']


    print '\nINITIALISATION\n====================\n'
    
    # create or get todomato
    

    # update task
    print '\nUPDATING\n====================\n'

    try:
        remote_tasklist, client, feed_uri = init(local_auth)
    except gdata.client.BadAuthentication:
        return jsonify({ 'error': "Authorization Error" }), 401

    # try:
    #     tasklist = update(client, feed_uri, local_tasklist, remote_tasklist, last_sync, time_offset)
    # except:
    #     return jsonify({ 'error': "Sync Error" }), 401

    print '\nRESPONDING\n====================\n', json.dumps(tasklist, sort_keys=True, indent=4)
    return jsonify({ 'tasklist': tasklist }), 201


if __name__ == '__main__':
    app.run(debug = True)




	// End of segment: C:\Users\Daryl Ho\Desktop\CS2103 Project\cs2103jan2014-t13-2j\src\todomato-sync-server\app.py





